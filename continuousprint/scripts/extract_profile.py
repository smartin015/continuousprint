import re
import sys
import os
from continuousprint.data import PRINTER_PROFILES


def _strip_nonalpha(s: str):
    assert type(s) is str
    return re.sub("[^0-9a-zA-Z]+", " ", s)


PROFILES = list(PRINTER_PROFILES.keys())
CANDIDATES = [
    set(_strip_nonalpha(k).split()).union(
        set(PRINTER_PROFILES[k].get("extra_tags", []))
    )
    for k in PROFILES
]


class KiriMotoProcessor:
    @classmethod
    def match(self, hdr, ftr):
        for line in hdr:
            if line.startswith("; Generated by Kiri:Moto"):
                return True
        return False

    @classmethod
    def get_profile(self, hdr, ftr) -> str:
        for line in hdr:
            if line.startswith("; Target:"):
                return re.match("; Target: (.*)", line)[1]
        return ""


class PrusaSlicerProcessor:
    @classmethod
    def match(self, hdr, ftr):
        for line in hdr:
            if line.startswith("; generated by PrusaSlicer"):
                return True
        return False

    @classmethod
    def get_profile(self, hdr, ftr) -> str:
        for line in ftr:
            if line.startswith("; printer_model = "):
                return re.match("; printer_model = (.*)", line)[1]
        return ""


class Simplify3DProcessor:
    @classmethod
    def match(self, hdr, ftr):
        for line in hdr:
            if line.startswith("; G-Code generated by Simplify3D"):
                return True
        return False

    @classmethod
    def get_profile(self, hdr, ftr) -> str:
        for line in hdr:
            m = re.match(";   profileName,(.*)", line)
            print(line, "->", m)
            if m is not None:
                return m[1]
        return ""


def token_string_match(profstr):
    # Remove non-alpha characters from profile string
    # Convert all into bag-of-words
    p = set(_strip_nonalpha(profstr).split())

    scores = [len(p.intersection(c)) for c in CANDIDATES]
    sys.stderr.write(f"Scoring '{profstr}':\n")
    desc = sorted(zip(PROFILES, scores), key=lambda x: x[1], reverse=True)
    for p, s in desc[:4]:
        if s == 0:
            continue
        sys.stderr.write(f"- {p}: {s}\n")
    sys.stderr.write("- ...\n")
    max_score = max(scores)
    if max_score < 1:
        return None
    max_index = scores.index(max_score)
    return PROFILES[max_index]


PROCESSORS = [
    (cls.__name__, cls.match, cls.get_profile)
    for cls in [KiriMotoProcessor, PrusaSlicerProcessor, Simplify3DProcessor]
]

gcode_move_re = re.compile("^G[012] .*")
gcode_multiline_re = re.compile("\nG[012] .*", re.M)


def get_header(path: str):
    hdr = []
    with open(path) as f:
        for line in f:
            if line.strip() == "":
                continue
            if gcode_move_re.match(line):
                return hdr
            hdr.append(line)
    return hdr


def get_footer(path: str):
    # Adapted from https://stackoverflow.com/a/54278929
    # Skip back until we start seeing gcode
    hdr = []
    JUMP = 200  # Num bytes to jump back and search for gcode
    with open(path, "rb") as f:
        try:  # catch OSError in case of a one line file
            f.seek(-JUMP, os.SEEK_END)
            while not gcode_multiline_re.match(f.read(JUMP).decode("utf8")):
                f.seek(-2 * JUMP, os.SEEK_CUR)
            f.seek(-JUMP, os.SEEK_END)
            for line in f:
                ln = line.decode("utf8")
                if ln.startswith(";"):
                    hdr.append(ln)
        except OSError:
            pass  # give up
    return hdr


def get_profile(hdr: list, ftr: list):
    for name, match, getprof in PROCESSORS:
        if match(hdr, ftr):
            sys.stderr.write(f"File matched with {name}\n")
            profstr = getprof(hdr, ftr)
            return token_string_match(profstr)


if __name__ == "__main__":
    sys.stderr.write("=== Continuous Print Profile Inference ===\n")
    hdr = get_header(sys.argv[1])
    ftr = get_footer(sys.argv[1])
    prof = get_profile(hdr, ftr)
    if prof is not None:
        sys.stdout.write(prof)
    sys.stdout.flush()
    sys.stderr.write("\n=== End Inference ===\n")
